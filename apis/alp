--[[
Address Layer Protocol

New design:

The core API automatically translates incoming
messages into ALP events which are received by
os.pullEvent.

Configuration: /config/alp.cfg
  {
    -- The computer's own address is specified as
    -- follows. It is 4 digit hexadecimal.
    -- If not specified, one will be made up.
    -- Addresses starting zero are considered local
    -- and not to be routed.
    address = "f123"
    
    -- Routing config hasn't been decided.
  }

Possible extensions:
* Encapsulation of a request/response style,
  so that we can associate received packets with
  the specific ones we've sent.
]]

local Alp = {}
Alp.__index = Alp

-- Creates an ALP object.
function create(eventHandler)
  local alp = {
    eventHandler = eventHandler,
    config = {},
    modems = {}, -- list of modem interface objects
    listening = {}, -- protocol -> callback
    hosting = {}, -- keys are protocols being hosted
    addressSide = {}, -- helps limit routing
  }
  setmetatable(alp, Alp)
  alp:_init(events)
  return alp
end

-- Returns the machine's configured address.
function Alp:getAddress()
  return self.config.address
end

-- Sends an ALP packet to the given address on
-- the given protocol containing the given data.
function Alp:send(address, protocol, data)
	self:_send(self.config.address, address, protocol, data)
end

-- Listens on the given protocol for packets.
-- The handler will be called for each packet
-- received, with parameters:
-- source, destination, protocol, data
function Alp:listen(protocol, handler, isHost)
  if self.listening[protocol] then
    return false
  end
  if next(self.listening) == nil then
    self:_listen()
  end
  self.listening[protocol] = handler
  if isHost then
    self.hosting[protocol] = true
  end
  return true
end

-- Stops listening for a given protocol.
function Alp:unlisten(protocol)
  self.listening[protocol] = nil
  self.hosting[protocol] = nil
  if next(self.listening) == nil then
    self:_unlisten()
  end
end

-- This will cause the event handler to poll
-- for events, triggering callbacks for all
-- registered event types which have occured.
-- It is acceptable to call the event handler's
-- pullEvent directly if its functionality is
-- needed.
function Alp:pullEvent()
  self.eventHandler:pullEvent()
end

-- This will poll the network for hosted services.
-- Returns a table with keys of addresses, and values
-- of tables of protocols.
function Alp:poll(blocking, wait)
  self:send("ffff", "alp.poll", {})
  if blocking then
    local hosts = {}
    local timer = os.startTimer(wait or 2)
    local function dummyHandler(src, dst, protocol, data)
      if protocol == "alp.poll.r" and type(data) == "table" then
        if not hosts[src] then
          hosts[src] = {}
        end
        for k,v in pairs(data) do
          table.insert(hosts[src], k)
        end
      end
    end
    self:listen("alp.poll.r", dummyHandler)
    while true do
      local evt, src, dst, protocol, data = self.eventHandler:pullEvent()
      if evt == "timer" then
        break
      end
    end
    self:unlisten("alp.poll.r")
    return hosts
  end
end

-- Sort of constructor.
function Alp:_init(eventHandler)
  local filename = "/config/alp.cfg"
  if fs.exists(filename) then
    local file = fs.open(filename, "r")
    if file then
      self.config = textutils.unserialize(file.readAll())
      file.close()
    end
  end
  if not self.config.address then
    -- Make up an address.
    self.config.address = tostring(os.getComputerID())
    local pad = math.max(1, 4 - string.len(self.config.address))
    self.config.address = string.rep("0", pad) .. self.config.address
  end
  self.modems = { peripheral.find("modem") }
end

-- Real send method.
function Alp:_send(src, dst, protocol, data, routing)
 local packet = {
    alp = "1",
    src = src,
    dst = dst,
    protocol = protocol,
    data = data,
    routing = routing
  }
  packet = textutils.serialize(packet)
  -- TODO: Implement working loopback
  for k,modem in pairs(self.modems) do
     modem.transmit(2906, 2906, packet)
  end
end

-- Set our listen handler using closures.
function Alp:_listen()
  for k,modem in pairs(self.modems) do
    modem.open(2906)
  end
  -- Like javascript closure stuff but names reversed.
  -- The nested function refers to our current 'self' as 'this' even after we return.
  local this = self
  local function listenHandler(side, freq, rfreq, msg, dist)
    if type(msg) ~= "string" then
      return
    end
    local packet = textutils.unserialize(msg)
    if type(packet) ~= "table"
      or not packet.alp
      or not packet.src
      or not packet.dst
      or not packet.protocol
      or not packet.data
      then
      return
    end
    if packet.alp ~= "1" then
      return
    end
    -- Routing.
    if this.config.routing then
      this.addressSide[packet.src] = side
      if not this.addressSide[packet.dst]
        or this.addressSide[packet.dst] ~= side
        then
        local routing = packet.routing
        if not routing then
          routing = {}
        end
        -- Only route if we haven't routed it before
        if not routing[config.address] then
          routing[this.config.address] = #routing
          this:_send(packet.src, packet.dst, packet.protocol, packet.data, routing)
        end
      end
    end
    -- Acept valid addresses.
    if packet.dst ~= this.config.address
      and packet.dst ~= "0000"
      and packet.dst ~= "ffff"
      then
      return
    end
    -- Automatically handle polling for services.
    if packet.protocol == "alp.poll" then
      this:send(packet.src, "alp.poll.r", this.hosting)
      return
    end
    -- Pass any other packets to the callback.
    if this.listening[packet.protocol] then
      this.listening[packet.protocol](packet.src, packet.dst, packet.protocol, packet.data)
      --os.queueEvent("alp_packet", packet.src, packet.dst, packet.protocol, packet.data)
    end
  end
  self.eventHandler:register("modem_message", listenHandler)
  self.handlerCallback = listenHandler
end

function Alp:_unlisten(eventHandler)
  for k,modem in pairs(self.modems) do
    modem.close(2906)
  end
  self.eventHandler:unregister("modem_message", self.handlerCallback)
  self.handlerCallback = nil
end

